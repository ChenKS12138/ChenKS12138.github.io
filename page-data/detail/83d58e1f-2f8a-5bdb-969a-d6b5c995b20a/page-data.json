{"componentChunkName":"component---src-pages-detail-tsx","path":"/detail/83d58e1f-2f8a-5bdb-969a-d6b5c995b20a","result":{"pageContext":{"html":"<h2>前言</h2>\n<p><code>redux</code>是一个<code>JavaScript</code>的状态容器，<code>redux-saga</code>是 redux 的一个中间件，<code>react-redux</code>是一个通过高阶函数的方式实现连接 redux 和 react 组件的库。<code>redux</code>有<code>state</code>,<code>action</code>,<code>dispatch</code>,<code>reducer</code>的概念。通过 dispatch 一个 action，调用 reducer 产生另个 state，替换 store 里的 state，实现状态的更新，react 再通过 diff 算法得到最小的需要更新的 dom，实现页面更新。</p>\n<h2>关于 Generator</h2>\n<p><code>redux-saga</code>使用了 ES6 的 Generator，因此我们需要对 Generator 有个认识。首先需要理解<code>迭代器</code>,<code>生成器</code>,<code>可迭代对象</code>。生成器是一个 Generator Function，可以返回一个迭代器。可以通过不断调用迭代器的 next 方法进行迭代。可迭代对象是一个具有[Symbol.iterator]的对象，常见的像<code>Array</code>，<code>Map</code>，<code>Set</code>都是属于可迭代对象，当然我们也可以构造自己的可迭代对象。</p>\n<pre><code class=\"language-javascript\">class BookShelf {\n  constructor() {\n    this.books = [];\n    this[Symbol.iterator] = function* () {\n      let index = 0;\n      while (index &#x3C; this.books.length) {\n        yield this.books[index++];\n      }\n      return;\n    };\n  }\n  add(bookName) {\n    this.books.push(bookName);\n  }\n}\nconst bookShelf = new BookShelf();\nbookShelf.add(\"book1\");\nbookShelf.add(\"book2\");\nbookShelf.add(\"book3\");\n\nfor (const book of bookShelf) {\n  console.log(book);\n}\n// book1\n// book2\n// book3\n</code></pre>\n<h2>关于 redux-saga</h2>\n<p>redux-saga 使得副作用更容易被管理。对于一些异步函数的调用，并不是在 Generator 函数内部执行，而是类似通过 yield 一个 Promise 的方式，在外部调用后，外部通过 next 方法，让 yield 左边得到返回值。这使得异步函数的调用更容易被测试。</p>\n<p>待补充。。。</p>","id":"83d58e1f-2f8a-5bdb-969a-d6b5c995b20a","headings":[{"value":"前言","depth":2},{"value":"关于 Generator","depth":2},{"value":"关于 redux-saga","depth":2}],"date":"Saturday, June 13, 2020 10:45 PM","tags":["JavaScript","随笔"],"title":"redux-saga初试"}}}