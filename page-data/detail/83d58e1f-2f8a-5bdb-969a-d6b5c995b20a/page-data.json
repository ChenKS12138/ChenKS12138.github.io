{"componentChunkName":"component---src-pages-detail-tsx","path":"/detail/83d58e1f-2f8a-5bdb-969a-d6b5c995b20a","result":{"pageContext":{"html":"<h2>前言</h2>\n<p><code>redux</code>是一个<code>JavaScript</code>的状态容器，<code>redux-saga</code>是 redux 的一个中间件，<code>react-redux</code>是一个通过高阶函数的方式实现连接 redux 和 react 组件的库。<code>redux</code>有<code>state</code>,<code>action</code>,<code>dispatch</code>,<code>reducer</code>的概念。通过 dispatch 一个 action，调用 reducer 产生另个 state，替换 store 里的 state，实现状态的更新，react 再通过 diff 算法得到最小的需要更新的 dom，实现页面更新。</p>\n<h2>关于 Generator</h2>\n<p><code>redux-saga</code>使用了 ES6 的 Generator，因此我们需要对 Generator 有个认识。首先需要理解<code>迭代器</code>,<code>生成器</code>,<code>可迭代对象</code>。生成器是一个 Generator Function，可以返回一个迭代器。可以通过不断调用迭代器的 next 方法进行迭代。可迭代对象是一个具有[Symbol.iterator]的对象，常见的像<code>Array</code>，<code>Map</code>，<code>Set</code>都是属于可迭代对象，当然我们也可以构造自己的可迭代对象。</p>\n<pre><code class=\"language-javascript\">class BookShelf {\n  constructor() {\n    this.books = [];\n    this[Symbol.iterator] = function* () {\n      let index = 0;\n      while (index &#x3C; this.books.length) {\n        yield this.books[index++];\n      }\n      return;\n    };\n  }\n  add(bookName) {\n    this.books.push(bookName);\n  }\n}\nconst bookShelf = new BookShelf();\nbookShelf.add(\"book1\");\nbookShelf.add(\"book2\");\nbookShelf.add(\"book3\");\n\nfor (const book of bookShelf) {\n  console.log(book);\n}\n// book1\n// book2\n// book3\n</code></pre>\n<h2>使用 Generator Function 处理异步函数</h2>\n<p>ES2017 的<code>async</code>,<code>await</code>给我们提供了一种同步的写法来编写异步逻辑的函数，但我们也可以通过<code>Promise</code>加上<code>Generator Function</code>达到和<code>async</code>,<code>await</code>类似一样的效果。并且后者更利于进行测试，这也是<code>redux-saga</code>处理副作用的方式。可以通过调用 Generator Function 产生一个 Iterator，对其进行迭代，确保每次迭代的结果符合预期，即测试成功。</p>\n<pre><code class=\"language-javascript\">/**\n * @param {number} second\n */\nconst sleep = second =>\n  new Promise((resolve, reject) => {\n    if (second &#x3C; 0) {\n      reject(\"second less than 0\");\n      return;\n    }\n    setTimeout(() => {\n      resolve(`Sleep ${second}ms`);\n    }, second);\n  });\n\n/**\n * @param {GeneratorFunction} generatorFunc\n */\nconst asyncWrapper = generatorFunc => {\n  const iterator = generatorFunc();\n  /**\n   * @param {Iterator} iterator\n   * @param {IteratorReturnResult} current\n   */\n  const handleIterate = (iterator, current) => {\n    if (current &#x26;&#x26; current.done) {\n      return;\n    } else if (current === undefined) {\n      handleIterate(iterator, iterator.next());\n    } else if (current.value instanceof Promise) {\n      current.value.then(\n        result => handleIterate(iterator, iterator.next(result)),\n        reason => handleIterate(iterator, iterator.throw(reason))\n      );\n    }\n  };\n  handleIterate(iterator);\n};\n\nasyncWrapper(function* () {\n  console.log(\"sleep start\");\n  const str1 = yield sleep(1000);\n  console.log(str1);\n  try {\n    const str2 = yield sleep(-1000);\n    console.log(str2);\n  } catch (error) {\n    console.log(`sleep error: ${error}`);\n  }\n  console.log(\"sleep end\");\n});\n// sleep start\n// Sleep 1000ms\n// sleep error: second less than 0\n// sleep end\n</code></pre>\n<h2>关于 redux-saga</h2>\n<p>redux-saga 使得副作用更容易被管理。对于一些异步函数的调用，并不是在 Generator 函数内部执行，而是类似通过 yield 一个 Promise 的方式，在外部调用后，外部通过 next 方法，让 yield 左边得到返回值。这使得异步函数的调用更容易被测试。</p>\n<p><code>redux-saga</code>中的几个概念。<code>saga辅助函数</code>，用于当特定的 action（或者是使用<code>*</code>同配所有的 action）被 dispatch 到 store 时派发任务，使用一定的 saga 处理。<code>saga</code>，一个可以多次 yield effect 的 Generator Function，通过 yield effect，处理异步逻辑。<code>effect</code>，可以通过<code>redux-saga/effects</code>的内置函数像<code>call</code>,<code>apply</code>,<code>cps</code>,<code>put</code>创建，也可以是一个普通的 Promise 对象，此时 yield 的左值就是 Promise 的 resolve 的 value，甚至可以是一个普通的 JavaScript 对象。</p>\n<p>更新中...</p>","id":"83d58e1f-2f8a-5bdb-969a-d6b5c995b20a","headings":[{"value":"前言","depth":2},{"value":"关于 Generator","depth":2},{"value":"使用 Generator Function 处理异步函数","depth":2},{"value":"关于 redux-saga","depth":2}],"date":"Saturday, June 13, 2020 10:45 PM","tags":["JavaScript","随笔"],"title":"redux-saga初试"}}}