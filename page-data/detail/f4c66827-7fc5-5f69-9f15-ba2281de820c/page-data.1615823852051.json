{"componentChunkName":"component---src-pages-detail-tsx","path":"/detail/f4c66827-7fc5-5f69-9f15-ba2281de820c","result":{"pageContext":{"html":"<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"https://cdn.jsdelivr.net/gh/ChenKS12138/ChenKS12138.github.io/static/81565c4b134625dde6eb15769b72eb1b/9c7c2/isomorphic-rendering-nyr-1.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 75%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAPABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAQCBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAeji8TqB/8QAHBAAAQMFAAAAAAAAAAAAAAAAAQACEQMEEBIU/9oACAEBAAEFAjbSeUJlLQSpGP/EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EAB4QAAAEBwAAAAAAAAAAAAAAAAABA5ECERITIDNx/9oACAEBAAY/AjO4o42qOJVxH3D/xAAZEAEAAwEBAAAAAAAAAAAAAAARAAEhEDH/2gAIAQEAAT8hqNm0qWnwmp1BXJfJ/9oADAMBAAIAAwAAABDzL//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EAB0QAQACAgIDAAAAAAAAAAAAAAEAESExQVGxwfD/2gAIAQEAAT8QbiWwQX0QQ8PziCpFyWug9TWXJKNeIh3pP//Z'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"nyr\"\n        title=\"nyr\"\n        src=\"https://cdn.jsdelivr.net/gh/ChenKS12138/ChenKS12138.github.io/static/81565c4b134625dde6eb15769b72eb1b/1c72d/isomorphic-rendering-nyr-1.jpg\"\n        srcset=\"https://cdn.jsdelivr.net/gh/ChenKS12138/ChenKS12138.github.io/static/81565c4b134625dde6eb15769b72eb1b/a80bd/isomorphic-rendering-nyr-1.jpg 148w,\nhttps://cdn.jsdelivr.net/gh/ChenKS12138/ChenKS12138.github.io/static/81565c4b134625dde6eb15769b72eb1b/1c91a/isomorphic-rendering-nyr-1.jpg 295w,\nhttps://cdn.jsdelivr.net/gh/ChenKS12138/ChenKS12138.github.io/static/81565c4b134625dde6eb15769b72eb1b/1c72d/isomorphic-rendering-nyr-1.jpg 590w,\nhttps://cdn.jsdelivr.net/gh/ChenKS12138/ChenKS12138.github.io/static/81565c4b134625dde6eb15769b72eb1b/a8a14/isomorphic-rendering-nyr-1.jpg 885w,\nhttps://cdn.jsdelivr.net/gh/ChenKS12138/ChenKS12138.github.io/static/81565c4b134625dde6eb15769b72eb1b/fbd2c/isomorphic-rendering-nyr-1.jpg 1180w,\nhttps://cdn.jsdelivr.net/gh/ChenKS12138/ChenKS12138.github.io/static/81565c4b134625dde6eb15769b72eb1b/9c7c2/isomorphic-rendering-nyr-1.jpg 1211w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<h2>前言</h2>\n<p>从一开始的静态网页以及浏览器的出现，出现了文档链接其他文档这样的交互方式。后来 JavaScript 的出现了，通过在文档中编写脚本，借助浏览器的能力，文档和用户的交互有了更多的可能。再到后来 PHP、ASP 以及各种 CGI 应用的出现，CGI 应用通过自身的访问数据库、文件系统等各种能力，动态的生成文档，返回给用户，文档的内容有了更多的可能，这就是服务端渲染（SSR）的大致过程。最初前端部分的代码在 CGI 应用中的占比不高，主要是以服务端的代码为主，嵌入一部分的前端代码无伤大雅，但是随着前端内容的不断膨胀，前端代码在 CGI 应用中的占比不断提高，从代码的可维护性和用户体验的角度上看，这样的服务端渲染的方式不再合适。</p>\n<p>后来衍生出了客户端渲染（CSR），前端代码从 CGI 应用中分离，文档的构建不再由 CGI 应用负责，而是用户获取到 JavaScript 脚本后，浏览器端执行 JavaScript 脚本动态的生成，并通过发送 ajax 请求和后端服务通信，获取到数据后，再通过 DOM 操作更新页面，可以理解为这是一个将 PJAX 做到了极致的技术。通过 CSR 可以实现单页应用，达到避免页面跳转时的白屏的目的，从工程的角度看，减少了代码的耦合，CGI 应用中的前端代码可以被分离出来作为一个独立的应用。但 CSR 也带来了些问题，用户下载到的文档是一个不包含内容的文档，需要执行 JavaScript 脚本后才可以构建出内容，这对于搜索引擎来说不够友好，如果搜素引擎没有执行脚本中的内容无法得到文档的内容，再者是页面首次加载会有白屏时间，用户体验不够好。</p>\n<p>造成上面的问题的最主要的一个点就是，在 CSR 应用中用户下载的 HTML 文档不包含内容，需要客户端执行完 JavaScript 脚本后，才可以得到内容。那么问题就来了，我们是不是可以让 JavaScript 脚本执行的过程在服务端中执行一遍，这样得到的 HTML 文档就包含了页面内容。同时，请求发生在服务端时延会比在客户端小，能提高总体的加载速度。</p>\n<p>市面上已经有了许多同构渲染的方案，例如 next.js、nuxt.js，但是我选择自己用 React、ReactDOM、Koa 实现一遍，以便于更好地理解这个过程，以及更好地做优化和故障排查。</p>\n<h2>同构渲染的主要过程</h2>\n<h3>传统的 CSR</h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 451px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"https://cdn.jsdelivr.net/gh/ChenKS12138/ChenKS12138.github.io/static/4fbdb341b172f42311182c9395fe70cd/38070/isomorphic-rendering-2.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 60.13513513513513%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsSAAALEgHS3X78AAACLElEQVQoz3VTS2sTYRSdKlWCIL5bQ7WhlhAJdohmFbLyRwgKtla0Rf+BkIVoGyoWus42y+xDfkB22YWQJyHv92uRxyTOJN94zjBVCfHCmfvN3O+c3FekUqn0qdPpXLTb7R/w541Gwx+NRrck2C0Y3FOA74+AXYvFYmUsEolsNZvNE3JM7gW0PkuLxUJftkqlckiSLMv34DaABwDPm06n8z5jiUTicJknhNCl0Wg0x1mFsAqvMJDL5T6SZLPZmNUT4DGwzbPVat1hDJW8NnXIIVcdj8dzCgp+haAwA3qxWHxPktvtvgO3Y4qyVLvL5eI3CXf2p9Opnk6n1WQyKVCu3u/3BQX/zdoQrNfr70jyeDzs4V0Tt1m21+u9yVgmkzng3VarpeIsZrOZzuT+CNJrmmYI4lePSHI4HOzfrjkYZulEG4yBoc9vzCSmgEYYJeNhNJMp42wIlstlYyjhcHgdbg24cukDgcA1xmq12lt9ha0sGWUckITjVWnJyKHFYrENDOYr1uUM90/hfyKpo5VDwYV9kkKh0PqyoM/nY7ZSKpWyo9dng8HgG/AdOMWgvkjD4dBYxPl8jsqFIZjNZj+QZLfbN7mOgAt4DrzYhjGG1Trm3clkoiuK8rdkc7GF+f6LD6R+TJLf778O95Dal6sTDAaNrPP5/CtVVXX8SxSUrna7XQ1rM+a0UtVqVS8UCgtA4F3g/aXZrzXpP4Ye3kCWcq/X20O5zyAox+Nxx29CeyT68Af8lQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"csr-render\"\n        title=\"csr-render\"\n        src=\"https://cdn.jsdelivr.net/gh/ChenKS12138/ChenKS12138.github.io/static/4fbdb341b172f42311182c9395fe70cd/38070/isomorphic-rendering-2.png\"\n        srcset=\"https://cdn.jsdelivr.net/gh/ChenKS12138/ChenKS12138.github.io/static/4fbdb341b172f42311182c9395fe70cd/12f09/isomorphic-rendering-2.png 148w,\nhttps://cdn.jsdelivr.net/gh/ChenKS12138/ChenKS12138.github.io/static/4fbdb341b172f42311182c9395fe70cd/e4a3f/isomorphic-rendering-2.png 295w,\nhttps://cdn.jsdelivr.net/gh/ChenKS12138/ChenKS12138.github.io/static/4fbdb341b172f42311182c9395fe70cd/38070/isomorphic-rendering-2.png 451w\"\n        sizes=\"(max-width: 451px) 100vw, 451px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<h3>同构渲染</h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"https://cdn.jsdelivr.net/gh/ChenKS12138/ChenKS12138.github.io/static/2ef66591fbc8e0b1d115ab40747659bf/91e7e/isomorphic-rendering-3.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 39.189189189189186%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsSAAALEgHS3X78AAABnklEQVQoz01Sy0rDUBC97hTUUoOxm8ZWTKGgFKF05ULoD7j0T/wBKaKrLlQiFDeuakF01c/oprRQSp90kSZp+q6JufFMSWouhMPMmTn3zNwwTdMKs9nsczqdlgeDwQ3DCYVCMUBUEIQT4Han07meTCZl1H2NRiOl1+vtMO/0+33BNM13cN+o+WBu4CDxxgIHqTVCJO/X2Lb9oyjKOdL7+HZLpdJVUIMtFgsbuKJgPB4/kUAkEokCjmRZliiG+7t/PVvN5/NnSJPL7WKxeMk5X4BziGfL5ZKvVisSdQ3DeCWBRCJxAIhD8JhiXdfvicdYfD6fG+12W/KnwPgp6gfnAvlaEMFaEMXPVJTJZPZonGw2G6YYznPEQ5jDrdFqtTaC3W43hT4bnAuO08icrFIDdvVCRaIokrO4JEkyxcPh8MEbmVuWpVer1Y1go9FIOY5j+TzDTlxfELcUqCiZTJKzcDqdFj2Hj16Dg3qzXq/HfMFms3mBHf5uBCGi4XXJpauqai74usAtQuRvvR3SFN1KpXLoC9ZqtVNcOMHY9JdYf69shEK4lHCiAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"csr-render\"\n        title=\"csr-render\"\n        src=\"https://cdn.jsdelivr.net/gh/ChenKS12138/ChenKS12138.github.io/static/2ef66591fbc8e0b1d115ab40747659bf/fcda8/isomorphic-rendering-3.png\"\n        srcset=\"https://cdn.jsdelivr.net/gh/ChenKS12138/ChenKS12138.github.io/static/2ef66591fbc8e0b1d115ab40747659bf/12f09/isomorphic-rendering-3.png 148w,\nhttps://cdn.jsdelivr.net/gh/ChenKS12138/ChenKS12138.github.io/static/2ef66591fbc8e0b1d115ab40747659bf/e4a3f/isomorphic-rendering-3.png 295w,\nhttps://cdn.jsdelivr.net/gh/ChenKS12138/ChenKS12138.github.io/static/2ef66591fbc8e0b1d115ab40747659bf/fcda8/isomorphic-rendering-3.png 590w,\nhttps://cdn.jsdelivr.net/gh/ChenKS12138/ChenKS12138.github.io/static/2ef66591fbc8e0b1d115ab40747659bf/91e7e/isomorphic-rendering-3.png 692w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>使用同构渲染技术，用户在获取到 HTML 时，文档就已经包含了内容，这可以较少应用的加载屏时长。React 是基于 Virtual DOM 来构建页面内容，可以使用 ReactDOM.render/ReactDOM.hydrate/renderToString 将 React 组件渲染出来。只不过，前两者传参需要一个 DOM 对象，ReactDOM 会操作这个 DOM，渲染出页面，而 renderToString 是直接输出 HTML 文本。hydrate 相比于 render 会对已有的内容进行 hydrate 操作。</p>\n<p>因此我们可以让 Server 也渲染一遍 React 组件，得到 HTML 文本后返回给用户，再配合 ReactDOM.hydrate，浏览器端在 DOM 中标记好处理事件。</p>\n<h2>主要需要解决的问题</h2>\n<h3>保证服务端和客户端 Virtual DOM 的一致性</h3>\n<p>客户端在构建页面时，目标 DOM 节点中已经存在了内容，因此我们需要传入 props，以保证 ReactDOM.hydrate 被调用后，构建出的 Virtual DOM 与目标 DOM 内容一致。</p>\n<p>我采用的方案是在文档初次渲染时，将服务端获取到的 initProps，序列化以及 base64 加密后注入到文档中，构建 Virtual DOM 时再解密以及反序列化。</p>\n<pre><code class=\"language-jsx\">var htmlTemplate = `&#x3C;!DOCTYPE html>\n&#x3C;html &#x3C;%- helmet.htmlAttributes.toString() %> >\n  &#x3C;head>\n    &#x3C;%- helmet.title.toString() %>\n    &#x3C;%- helmet.meta.toString() %>\n    &#x3C;%- helmet.link.toString() %>\n  &#x3C;/head>\n  &#x3C;body &#x3C;%- helmet.bodyAttributes.toString() %> >\n    &#x3C;div id=\"root\">&#x3C;%- content %>&#x3C;/div>\n  &#x3C;/body>\n  &#x3C;script>\n    window.__PRERENDER_INIT_PAGE_PROPS__ = \"&#x3C;%- initPageProps %>\";\n  &#x3C;/script>\n&#x3C;/html>\n`;\n\nReactDOM.hydrate(\n  &#x3C;App\n    initPath={location.pathname}\n    initPageProps={parserProps(window.__PRERENDER_INIT_PAGE_PROPS__)}\n  />,\n  document.getElementById(\"root\")\n);\n</code></pre>\n<h3>保证前后端路由解析的一致性</h3>\n<p>首次进入页面时依赖的是后端的路由，Koa 中间件需要解析出对应的页面组件，并调用其<code>getInitProps</code> 获取到数据，渲染组件以及注入页面。因此需要保证前后端路由解析的结果的一致性。最初我使用的<code>react-router-config</code>和<code>koa-router</code> 来分别实现前后端路由解析，后面为了保证解析结果的一致性，我使用了<code>path-to-regexp</code>和<code>query-string</code>实现了路由解析，并编写了对应的单元测试</p>\n<h3>CSS Modules 服务端解析的问题</h3>\n<pre><code class=\"language-javascript\">import styles from \"home.module.css\";\nconsole.log(styles);\n/**\n * 服务端结果\n   [\n    [\n      './src/containers/Home/home.module.css',\n      '._2qPY_oWAq232nd_VnG32FK {\\n  color: red;\\n}\\n',\n      ''\n    ],\n    toString: [Function: toString],\n    i: [Function (anonymous)],\n    locals: { text: '_2qPY_oWAq232nd_VnG32FK' }\n  ]\n  * 客户端结果\n    { text: '_2qPY_oWAq232nd_VnG32FK' }\n */\n</code></pre>\n<p>服务端在进行<code>CSS Modules</code>解析时得到了意料之外的结果，到目前我还没找到问题的原因。经过一番 Google 后，看到其他人也有类似的情况出现，但是其他人的解决方案的 babel plugin 并不能解决我的问题。所以我直接写了一个 babel plugin 以及对应的单元测试，转译出服务端代码时进行转换，操作 AST，以保证<code>styles</code>为<code>locals</code>中的内容。</p>\n<pre><code class=\"language-javascript\">var t = require(\"@babel/types\");\n\n/**\n *  transfrom  import styles from \"home.module.css\";\n *         to  import __styles from \"home.module.css\";\n *             var styles = __styles.locals;\n */\n\nmodule.exports = {\n  visitor: {\n    ImportDefaultSpecifier(path) {\n      var parent = path.parent;\n      var node = path.node;\n      if (\n        t.isImportDeclaration(parent) &#x26;&#x26;\n        /\\.module\\.css/.test(parent.source.value)\n      ) {\n        var originName = node.local.name;\n        node.local.name = \"__\" + originName;\n        path.parentPath.insertAfter(\n          t.variableDeclaration(\"var\", [\n            t.variableDeclarator(\n              t.identifier(originName),\n              t.memberExpression(\n                t.identifier(node.local.name),\n                t.identifier(\"locals\")\n              )\n            ),\n          ])\n        );\n      }\n    },\n  },\n};\n</code></pre>\n<h3>使用 Cluster 提高性能</h3>\n<p>为了更好地利用主机的计算资源，我使用了 Node.js 中的 Cluster 模块，进行多进程优化。</p>\n<pre><code class=\"language-javascript\">import * as cluster from \"cluster\";\nimport * as os from \"os\";\n\nexport function run(worker: () => void) {\n  if (ENALBE_SERVER_CLUSTER) {\n    const cpuNum = os.cpus().length;\n    if (cluster.isMaster) {\n      for (let i = 0; i &#x3C; cpuNum; i++) {\n        cluster.fork();\n      }\n      console.log(`start ${cpuNum} process`);\n      cluster.on(\"exit\", (worker, code, signal) => {\n        console.log(`worker ${worker.process.pid} exited`);\n      });\n    } else {\n      worker();\n    }\n  } else {\n    worker();\n  }\n}\n\nrun(() => {\n  const app = new Koa();\n  middlewares.forEach(middleware => {\n    app.use(middleware);\n  });\n  app.listen(SERVER_PORT, () => {\n    console.log(`worker ready, listen request from 0.0.0.0:${SERVER_PORT}`);\n  });\n});\n</code></pre>\n<h2>小结</h2>\n<p>这只是一个简单的同构渲染的实践，可以做优化的地方还很多。欢迎 clone 源码自己看一遍，欢迎 Pull Request。等等，发现跑题了，NYR 是和小伙伴们想一起做的 PT 站<del>，在线等其他有缘人一起把 NYR 写完</del>。</p>\n<p><a href=\"https://github.com/NJUPT-NYR/SOPT-Frontend\">https://github.com/NJUPT-NYR/SOPT-Frontend</a></p>","id":"f4c66827-7fc5-5f69-9f15-ba2281de820c","headings":[{"value":"前言","depth":2},{"value":"同构渲染的主要过程","depth":2},{"value":"传统的 CSR","depth":3},{"value":"同构渲染","depth":3},{"value":"主要需要解决的问题","depth":2},{"value":"保证服务端和客户端 Virtual DOM 的一致性","depth":3},{"value":"保证前后端路由解析的一致性","depth":3},{"value":"CSS Modules 服务端解析的问题","depth":3},{"value":"使用 Cluster 提高性能","depth":3},{"value":"小结","depth":2}],"date":"Friday, February 12, 2021 3:57 PM","tags":["随笔"],"title":"搭建一个基于同构渲染的NYR"}},"staticQueryHashes":["63159454"]}