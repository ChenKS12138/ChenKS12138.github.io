{"componentChunkName":"component---src-pages-detail-tsx","path":"/detail/9c86f700-3cc4-5fde-be49-df5ea8a03cd6","result":{"pageContext":{"html":"<h2>一道题目</h2>\n<p>这是 ScriptOJ 上的一道题目 => <a href=\"http://scriptoj.mangojuice.top/problems/102\">传送门</a>\n<code>记忆化斐波那契函数（Memoization）</code>\n题目是这样的</p>\n<blockquote>\n<p><strong>斐波那契数列</strong>指的是类似于以下的数列：</p>\n<p>1, 1, 2, 3, 5, 8, 13, ....\n也就是，第 n 个数由数列的前两个相加而来：<strong>f(n) = f(n - 1) + f(n -2)</strong>\n请你完成 fibonacci 函数，接受 n 作为参数，可以获取数列中第 n 个数，例如：</p>\n<p>fibonacci(3) // => 2</p>\n<p>fibonacci(2) // => 1</p>\n<p>fibonacci(3) // => 2</p>\n<p>...</p>\n<p>测试程序会从按顺序依次获取斐波那契数列中的数，请注意程序不要超时，也不要添加额外的全局变量。</p>\n</blockquote>\n<h3>常规做法</h3>\n<p>一般来说，斐波那契数列，我们会选择使用递归函数来解决，正如题目中所给的那样 <code>f(n)=f(n-1)+f(n-2)</code> 我们只要当 n 小于 2 时返回 1 就可以了。\n用 JavaScript 处理后就是这样</p>\n<deckgo-highlight-code language=\"JavaScript\"  >\n          <code slot=\"code\">const fibonacci = n =&gt; n &gt; 2 ? fibonacci(n-1) + fibonacci(n-2) : 1;\nfor(let i = 1 ;i &lt; 7;i++) console.log(fibonacci(i))\n/**\n * 运行结果：\n * 1\n * 1\n * 2\n * 3\n * 5\n * 8\n */</code>\n        </deckgo-highlight-code>\n<p>这样处理对程序员来说确实比较轻松，几乎不用写什么逻辑，但缺点也很明显，这样递归占用空间较大，效率较低，容易超时。</p>\n<h3>使用 JavaScript 的闭包</h3>\n<p>我们可以看出一个很明显的特点，题目所给的数据是从 1 依次递增的，因此如果我们可以将前两次的数据存储下来，无疑可以减少很多不必要的计算量。</p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">const fibonacci = (() =&gt; {\n  const temp = [1, 1];\n  return function (n) {\n    if (n === 1 || n === 2) return 1;\n    const result = temp[n - 2] + temp[n - 3];\n    temp.push(result);\n    return result;\n  };\n})();</code>\n        </deckgo-highlight-code>\n<p>运行结果如下：</p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">for (let i = 1; i &lt; 9; i++) {\n  console.log(fibonacci(i));\n}\n/**\n1\n1\n2\n3\n5\n8\n13\n21\n*/</code>\n        </deckgo-highlight-code>\n<p>并且使用闭包后能通过测试了。甚至我们还可以继续压缩代码，变成只剩一行代码。<del>看起来真得很爽，强迫症</del></p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">const fibonacci = (temp =&gt; n =&gt;\n  n === 1 || n === 2 ? 1 : (temp[n - 1] = temp[n - 2] + temp[n - 3]))([1, 1]);</code>\n        </deckgo-highlight-code>\n<p>使用闭包后，变量<code>fibonacci</code>不仅是个函数，并且是另一个函数的返回值，<code>temp</code>是另一个函数中的局部变量，同时，<code>fibonacci</code>又依赖于变量<code>temp</code>，因此虽然<code>temp</code>已经超出它的作用域了，但是<code>temp</code>并没有被垃圾回收机制（garbage collection）回收。同时，对于每一处调用的<code>fibonacci</code>对应的都是同一个<code>temp</code>。这样就可以对每次的结果进行记录。</p>","id":"9c86f700-3cc4-5fde-be49-df5ea8a03cd6","headings":[{"value":"一道题目","depth":2},{"value":"常规做法","depth":3},{"value":"使用 JavaScript 的闭包","depth":3}],"date":"Monday, July 22, 2019 3:35 PM","tags":["JavaScript"],"title":"JavaScript中的闭包"}}}