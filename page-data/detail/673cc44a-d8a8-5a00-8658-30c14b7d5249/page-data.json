{"componentChunkName":"component---src-pages-detail-tsx","path":"/detail/673cc44a-d8a8-5a00-8658-30c14b7d5249","result":{"pageContext":{"html":"<h2>前言</h2>\n<p>我的主力开发语言是<code>JavaScript</code>，但是 js 对多线程的支持并不是特别好。在入门<code>golang</code>后，了解到了<code>go协程</code>和<code>channel</code>，想试一试多线程。<code>go</code>原生对并发很友好，我这里是希望尝试使用<code>go协程</code>优化大数组求和。</p>\n<h2>对比</h2>\n<p>进行对比的两个函数</p>\n<ol>\n<li><code>func sum1(bigArray []int) int</code> 使用普通的数组求和</li>\n<li><code>func sum2(bigArray []int)int</code>将数组分割成若干个数组，在不同的<code>go协程</code>进行求和，所有的<code>go协程</code>都得到结果后，再进行求和</li>\n</ol>\n<pre><code class=\"language-go\">package main\n\nimport (\n    \"math/rand\"\n    \"fmt\"\n    \"sync\"\n    \"time\"\n)\n\nfunc main(){\n    for i:=1000;i&#x3C;10000000000;i*=2 {\n        duration1,duration2,result1,result2 := runBenchmark(i);\n        fmt.Println(i,duration1,duration2,result1,result2)\n    }\n}\n\n\nfunc runBenchmark(amout int) (int64,int64,int64,int64) {\n    bigArray :=createBigArray(amout);\n    stop1 := createTimer();\n    result1 := sum1(bigArray);\n    duration1 := stop1();\n    stop2 :=createTimer();\n    result2 := sum2(bigArray);\n    duration2 := stop2();\n    return duration1,duration2,result1,result2;\n}\n\nfunc createBigArray(size int)[]int{\n    rand.Seed(time.Now().Unix());\n    list := make([]int,size);\n    for i:=0;i&#x3C;size;i++{\n        list[i] = rand.Int()\n    }\n    return list;\n}\n\nfunc createTimer() func () int64 {\n    startTime := time.Now().UnixNano()\n    return func () int64 {\n        return time.Now().UnixNano() - startTime\n    }\n}\n\nfunc sum1(bigArray []int) int64 {\n    sum := int64(0)\n    for _,value := range(bigArray){\n        sum += int64(value);\n    }\n    return sum;\n}\n\nfunc sum2(bigArray []int)int64 {\n    SmallArraySize := len(bigArray)/100;\n    sum:=int64(0);\n    chanGroupSize := len(bigArray)/SmallArraySize;\n    sumChan := make(chan int64,chanGroupSize+1);\n    waitGroup := new(sync.WaitGroup);\n    for i:=0;i&#x3C;chanGroupSize;i++{\n        waitGroup.Add(1);\n        go sumRoutine(bigArray[i*SmallArraySize:(i+1)*SmallArraySize], sumChan, waitGroup)\n    }\n    waitGroup.Wait()\n    for i:=0;i&#x3C;chanGroupSize;i++ {\n        sum+= &#x3C;- sumChan;\n    }\n    return sum;\n}\n\nfunc sumRoutine(smallArray []int,ch chan int64,wg *sync.WaitGroup){\n    defer wg.Done()\n    sum :=int64(0);\n    for _,value := range(smallArray){\n        sum +=int64(value);\n    }\n    ch &#x3C;- sum;\n}\n</code></pre>\n<h2>进行测试</h2>\n<p>首先我在自己的笔记本上跑了一下，效果似乎不是特别明显，当数据规模比较小时，使用<code>go协程</code>产生的开销相比多线程带来的性能提升会比较大。</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/453870e8b4e58d00f85b8d27a7400537/a13c9/goroutine-env.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 56.75675675675676%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAAsSAAALEgHS3X78AAABzUlEQVQoz11STW/TQBT0FQkOCHFACIFagQSxd9f22o6/PzeJ7dpxRNMmaYHGThBwq1pOwIVfwE9mEtOoQhqt189vZmfnWToX8aKJwzgNwygIwjTNfvz8dXP7ve022+3nL1+/Xa3brttgRcN9+H4o2Tq3TV1VuaZxXTewup7vecFw6FiWDRiGZZpDgDFNVfUDGNMlyjRCNUpVeaDIA1keEEWhAFpN04KK43hgQotzE8UDQJGggQejNJ/kp/NFmiSU7Mij0bhtNx8/XeV5WRQndd3AJ+qEMAAUQtmeTOj8cmvNbh+/q52iy08aRVZgGN1Y++vgWPi3bbcH6pCQICbEeHH955l2+vxt+PA4qz7coD1Jsrbtqmp6draYz89ns/fw4rp+FCUQxYYQKsmykhe1WP9+qQRHR29eDPzJ8ppzI47T6bTJslGeF5NJUZYVaDi8T6Q3LxGi2kMnna4fvTIfPD1+8trNm0tGGVrLsoYEmHCBzJAcDB8y35ExJBgIgygSNffG2biCliwT9K1WF2AKMVouV1BBcRftXdo78t2OGhwDtTRVV/ZhIqE0FRgVVLJMOI57n/mPvB83XjAwrf/c/yqo4259pR+7qmr/kf8Cm2+Yt2nNrGkAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"env-mbp\"\n        title=\"env-mbp\"\n        src=\"/static/453870e8b4e58d00f85b8d27a7400537/fcda8/goroutine-env.png\"\n        srcset=\"/static/453870e8b4e58d00f85b8d27a7400537/12f09/goroutine-env.png 148w,\n/static/453870e8b4e58d00f85b8d27a7400537/e4a3f/goroutine-env.png 295w,\n/static/453870e8b4e58d00f85b8d27a7400537/fcda8/goroutine-env.png 590w,\n/static/453870e8b4e58d00f85b8d27a7400537/efc66/goroutine-env.png 885w,\n/static/453870e8b4e58d00f85b8d27a7400537/a13c9/goroutine-env.png 1178w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<pre><code>数据规模 sum1函数耗时(ns) sum2函数耗时(ns)\n1000    1000    257000\n2000    2000    196000\n4000    3000    123000\n8000    19000   566000\n16000   24000   574000\n32000   21000   106000\n64000   46000   101000\n128000  92000   117000\n256000  161000  164000\n512000  710000  354000\n1024000 633000  380000\n2048000 1855000 746000\n4096000 3779000 1430000\n8192000 9285000 7126000\n16384000    17107000    7522000\n32768000    37100000    16824000\n65536000    71186000    28741000\n131072000   153552000   55689000\n262144000   349672000   125364000\n524288000   3370025000  221678000\n</code></pre>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/6b1a2cd90b4f316614f2a1f0b93598cd/6f969/goroutine-bench1.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 30.405405405405407%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAAAsSAAALEgHS3X78AAAAqUlEQVQY042QCwoDIQxE9/633AOUQlvdfJ3GWLsfKFQYMsTkGbOoKtz9p1pr6DXMnP589/WOOBHWpRf2hmvxP1JzkBjMLsA5STtMdfR+8i1BogNoI78DiWgmR8MnzubprUNCrCPOu3zsClQOaHxbVaAiuYJUeOYhkZFzO8uix912oFvsgCokvk5bRS1leNrSuwnq64nH/QZ0gBB4K2gBMmFwLX09CYz1rW8NA9kRyVme8AAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"bench1\"\n        title=\"bench1\"\n        src=\"/static/6b1a2cd90b4f316614f2a1f0b93598cd/fcda8/goroutine-bench1.png\"\n        srcset=\"/static/6b1a2cd90b4f316614f2a1f0b93598cd/12f09/goroutine-bench1.png 148w,\n/static/6b1a2cd90b4f316614f2a1f0b93598cd/e4a3f/goroutine-bench1.png 295w,\n/static/6b1a2cd90b4f316614f2a1f0b93598cd/fcda8/goroutine-bench1.png 590w,\n/static/6b1a2cd90b4f316614f2a1f0b93598cd/efc66/goroutine-bench1.png 885w,\n/static/6b1a2cd90b4f316614f2a1f0b93598cd/c83ae/goroutine-bench1.png 1180w,\n/static/6b1a2cd90b4f316614f2a1f0b93598cd/6f969/goroutine-bench1.png 2518w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<hr>\n<p>后面我使用了一台 8 核 16GB 内存的云服务器进行测试，效果就比较明显了。sum2 函数的耗时明显降低。</p>\n<pre><code>processor   : 6\nvendor_id   : GenuineIntel\ncpu family  : 6\nmodel       : 85\nmodel name  : Intel(R) Xeon(R) Platinum 8255C CPU @ 2.50GHz\nstepping    : 5\nmicrocode   : 0x1\ncpu MHz     : 2494.140\ncache size  : 36608 KB\nphysical id : 0\nsiblings    : 8\ncore id     : 6\ncpu cores   : 8\napicid      : 6\ninitial apicid  : 6\nfpu     : yes\nfpu_exception   : yes\ncpuid level : 13\nwp      : yes\n</code></pre>\n<pre><code>数据规模 sum1函数耗时(ns) sum2函数耗时(ns)\n1000    975 184791\n2000    1744    136564\n4000    2452    77209\n8000    4462    148065\n16000   13041   151411\n32000   17729   99903\n64000   34824   88240\n128000  72507   88009\n256000  153425  118217\n512000  307149  128954\n1024000 716739  218762\n2048000 1498043 340398\n4096000 3121459 741179\n8192000 6512778 1440240\n16384000    12999638    2841228\n32768000    25421817    5573615\n65536000    52787702    11216755\n131072000   102977136   22564239\n262144000   212568740   48269912\n524288000   408104714   90059294\n</code></pre>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/3a85a25e684b67a0d452a9d58e86f22f/27f8b/goroutine-bench2.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 39.86486486486486%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsSAAALEgHS3X78AAAA/ElEQVQoz21SC67EIAj0/nfd1FeroqA8Rmu3bdZkAiIMP12tVYlIW2s/0XvXlNIA9MfbKeVmc6UUjTFewXeipePg3m92kaaVm+bCynKS25tDZu/9FSwiA0tvTYYzMxuBKFXRRHUQ4Q7719cqDCHocRwPwlnh1NmCEAxQRTUz4apWXiNyOedB2HUeGNFCQTtWDZnkNgNH28OnT4Cc65OQqKjfNi2UNWW6gNlKLdpKUqHjlC+UPKX5YaZI6JCRzXj4TWuOmnavnIL2agnCn7I5d5tjCLvpVo2wRutITKLqaDvAMjBLLNeB9X5WW6N9bNQu2b7Vvn0GwRrL8n3r/zWgdjwWpOZWAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"bench2\"\n        title=\"bench2\"\n        src=\"/static/3a85a25e684b67a0d452a9d58e86f22f/fcda8/goroutine-bench2.png\"\n        srcset=\"/static/3a85a25e684b67a0d452a9d58e86f22f/12f09/goroutine-bench2.png 148w,\n/static/3a85a25e684b67a0d452a9d58e86f22f/e4a3f/goroutine-bench2.png 295w,\n/static/3a85a25e684b67a0d452a9d58e86f22f/fcda8/goroutine-bench2.png 590w,\n/static/3a85a25e684b67a0d452a9d58e86f22f/efc66/goroutine-bench2.png 885w,\n/static/3a85a25e684b67a0d452a9d58e86f22f/c83ae/goroutine-bench2.png 1180w,\n/static/3a85a25e684b67a0d452a9d58e86f22f/27f8b/goroutine-bench2.png 1730w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<h2>分析</h2>\n<p>在求和数组规模数据规模比较大，运行的机器核心数比较多的时候，使用<code>go协程</code>是可以提升数组求和的效率的。<code>go协程</code>和系统的进程并不是一一对应的，创建一个<code>go协程</code>本身的开销也比创建一个线程小。对大数组求和只是一种场景，也有很多其他类似的场景可以利用<code>go协程</code>进行优化。</p>","id":"673cc44a-d8a8-5a00-8658-30c14b7d5249","headings":[{"value":"前言","depth":2},{"value":"对比","depth":2},{"value":"进行测试","depth":2},{"value":"分析","depth":2}],"date":"Monday, July 27, 2020 1:11 PM","tags":["go","随笔"],"title":"使用go协程优化求和算法"}},"staticQueryHashes":["63159454"]}