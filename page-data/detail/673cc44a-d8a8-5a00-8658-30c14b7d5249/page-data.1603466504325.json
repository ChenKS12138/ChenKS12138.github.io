{"componentChunkName":"component---src-pages-detail-tsx","path":"/detail/673cc44a-d8a8-5a00-8658-30c14b7d5249","result":{"pageContext":{"html":"<h2>前言</h2>\n<p>我的主力开发语言是<code>JavaScript</code>，但是 js 对多线程的支持并不是特别好。在入门<code>golang</code>后，了解到了<code>go协程</code>和<code>channel</code>，想试一试多线程。<code>go</code>原生对并发很友好，我这里是希望尝试使用<code>go协程</code>优化大数组求和。</p>\n<h2>对比</h2>\n<p>进行对比的两个函数</p>\n<ol>\n<li><code>func sum1(bigArray []int) int</code> 使用普通的数组求和</li>\n<li><code>func sum2(bigArray []int)int</code>将数组分割成若干个数组，在不同的<code>go协程</code>进行求和，所有的<code>go协程</code>都得到结果后，再进行求和</li>\n</ol>\n<deckgo-highlight-code language=\"go\"  >\n          <code slot=\"code\">package main\n\nimport (\n\t&quot;math/rand&quot;\n\t&quot;fmt&quot;\n\t&quot;sync&quot;\n\t&quot;time&quot;\n)\n\nfunc main(){\n\tfor i:=1000;i&lt;10000000000;i*=2 {\n\t\tduration1,duration2,result1,result2 := runBenchmark(i);\n\t\tfmt.Println(i,duration1,duration2,result1,result2)\n\t}\n}\n\n\nfunc runBenchmark(amout int) (int64,int64,int64,int64) {\n\tbigArray :=createBigArray(amout);\n\tstop1 := createTimer();\n\tresult1 := sum1(bigArray);\n\tduration1 := stop1();\n\tstop2 :=createTimer();\n\tresult2 := sum2(bigArray);\n\tduration2 := stop2();\n\treturn duration1,duration2,result1,result2;\n}\n\nfunc createBigArray(size int)[]int{\n\trand.Seed(time.Now().Unix());\n\tlist := make([]int,size);\n\tfor i:=0;i&lt;size;i++{\n\t\tlist[i] = rand.Int()\n\t}\n\treturn list;\n}\n\nfunc createTimer() func () int64 {\n\tstartTime := time.Now().UnixNano()\n\treturn func () int64 {\n\t\treturn time.Now().UnixNano() - startTime\n\t}\n}\n\nfunc sum1(bigArray []int) int64 {\n\tsum := int64(0)\n\tfor _,value := range(bigArray){\n\t\tsum += int64(value);\n\t}\n\treturn sum;\n}\n\nfunc sum2(bigArray []int)int64 {\n\tSmallArraySize := len(bigArray)/100;\n\tsum:=int64(0);\n\tchanGroupSize := len(bigArray)/SmallArraySize;\n\tsumChan := make(chan int64,chanGroupSize+1);\n\twaitGroup := new(sync.WaitGroup);\n\tfor i:=0;i&lt;chanGroupSize;i++{\n\t\twaitGroup.Add(1);\n\t\tgo sumRoutine(bigArray[i*SmallArraySize:(i+1)*SmallArraySize], sumChan, waitGroup)\n\t}\n\twaitGroup.Wait()\n\tfor i:=0;i&lt;chanGroupSize;i++ {\n\t\tsum+= &lt;- sumChan;\n\t}\n\treturn sum;\n}\n\nfunc sumRoutine(smallArray []int,ch chan int64,wg *sync.WaitGroup){\n\tdefer wg.Done()\n\tsum :=int64(0);\n\tfor _,value := range(smallArray){\n\t\tsum +=int64(value);\n\t}\n\tch &lt;- sum;\n}</code>\n        </deckgo-highlight-code>\n<h2>进行测试</h2>\n<p>首先我在自己的笔记本上跑了一下，效果似乎不是特别明显，当数据规模比较小时，使用<code>go协程</code>产生的开销相比多线程带来的性能提升会比较大。</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"https://cdn.jsdelivr.net/gh/ChenKS12138/ChenKS12138.github.io/static/453870e8b4e58d00f85b8d27a7400537/a13c9/goroutine-env.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 56.75675675675676%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAAsSAAALEgHS3X78AAABzUlEQVQoz11STW/TQBT0FQkOCHFACIFagQSxd9f22o6/PzeJ7dpxRNMmaYHGThBwq1pOwIVfwE9mEtOoQhqt189vZmfnWToX8aKJwzgNwygIwjTNfvz8dXP7ve022+3nL1+/Xa3brttgRcN9+H4o2Tq3TV1VuaZxXTewup7vecFw6FiWDRiGZZpDgDFNVfUDGNMlyjRCNUpVeaDIA1keEEWhAFpN04KK43hgQotzE8UDQJGggQejNJ/kp/NFmiSU7Mij0bhtNx8/XeV5WRQndd3AJ+qEMAAUQtmeTOj8cmvNbh+/q52iy08aRVZgGN1Y++vgWPi3bbcH6pCQICbEeHH955l2+vxt+PA4qz7coD1Jsrbtqmp6draYz89ns/fw4rp+FCUQxYYQKsmykhe1WP9+qQRHR29eDPzJ8ppzI47T6bTJslGeF5NJUZYVaDi8T6Q3LxGi2kMnna4fvTIfPD1+8trNm0tGGVrLsoYEmHCBzJAcDB8y35ExJBgIgygSNffG2biCliwT9K1WF2AKMVouV1BBcRftXdo78t2OGhwDtTRVV/ZhIqE0FRgVVLJMOI57n/mPvB83XjAwrf/c/yqo4259pR+7qmr/kf8Cm2+Yt2nNrGkAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"env-mbp\"\n        title=\"env-mbp\"\n        src=\"https://cdn.jsdelivr.net/gh/ChenKS12138/ChenKS12138.github.io/static/453870e8b4e58d00f85b8d27a7400537/fcda8/goroutine-env.png\"\n        srcset=\"https://cdn.jsdelivr.net/gh/ChenKS12138/ChenKS12138.github.io/static/453870e8b4e58d00f85b8d27a7400537/12f09/goroutine-env.png 148w,\nhttps://cdn.jsdelivr.net/gh/ChenKS12138/ChenKS12138.github.io/static/453870e8b4e58d00f85b8d27a7400537/e4a3f/goroutine-env.png 295w,\nhttps://cdn.jsdelivr.net/gh/ChenKS12138/ChenKS12138.github.io/static/453870e8b4e58d00f85b8d27a7400537/fcda8/goroutine-env.png 590w,\nhttps://cdn.jsdelivr.net/gh/ChenKS12138/ChenKS12138.github.io/static/453870e8b4e58d00f85b8d27a7400537/efc66/goroutine-env.png 885w,\nhttps://cdn.jsdelivr.net/gh/ChenKS12138/ChenKS12138.github.io/static/453870e8b4e58d00f85b8d27a7400537/a13c9/goroutine-env.png 1178w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<deckgo-highlight-code   >\n          <code slot=\"code\">数据规模 sum1函数耗时(ns) sum2函数耗时(ns)\n1000\t1000\t257000\n2000\t2000\t196000\n4000\t3000\t123000\n8000\t19000\t566000\n16000\t24000\t574000\n32000\t21000\t106000\n64000\t46000\t101000\n128000\t92000\t117000\n256000\t161000\t164000\n512000\t710000\t354000\n1024000\t633000\t380000\n2048000\t1855000\t746000\n4096000\t3779000\t1430000\n8192000\t9285000\t7126000\n16384000\t17107000\t7522000\n32768000\t37100000\t16824000\n65536000\t71186000\t28741000\n131072000\t153552000\t55689000\n262144000\t349672000\t125364000\n524288000\t3370025000\t221678000</code>\n        </deckgo-highlight-code>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"https://cdn.jsdelivr.net/gh/ChenKS12138/ChenKS12138.github.io/static/6b1a2cd90b4f316614f2a1f0b93598cd/6f969/goroutine-bench1.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 30.405405405405407%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAAAsSAAALEgHS3X78AAAAqUlEQVQY042QCwoDIQxE9/633AOUQlvdfJ3GWLsfKFQYMsTkGbOoKtz9p1pr6DXMnP589/WOOBHWpRf2hmvxP1JzkBjMLsA5STtMdfR+8i1BogNoI78DiWgmR8MnzubprUNCrCPOu3zsClQOaHxbVaAiuYJUeOYhkZFzO8uix912oFvsgCokvk5bRS1leNrSuwnq64nH/QZ0gBB4K2gBMmFwLX09CYz1rW8NA9kRyVme8AAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"bench1\"\n        title=\"bench1\"\n        src=\"https://cdn.jsdelivr.net/gh/ChenKS12138/ChenKS12138.github.io/static/6b1a2cd90b4f316614f2a1f0b93598cd/fcda8/goroutine-bench1.png\"\n        srcset=\"https://cdn.jsdelivr.net/gh/ChenKS12138/ChenKS12138.github.io/static/6b1a2cd90b4f316614f2a1f0b93598cd/12f09/goroutine-bench1.png 148w,\nhttps://cdn.jsdelivr.net/gh/ChenKS12138/ChenKS12138.github.io/static/6b1a2cd90b4f316614f2a1f0b93598cd/e4a3f/goroutine-bench1.png 295w,\nhttps://cdn.jsdelivr.net/gh/ChenKS12138/ChenKS12138.github.io/static/6b1a2cd90b4f316614f2a1f0b93598cd/fcda8/goroutine-bench1.png 590w,\nhttps://cdn.jsdelivr.net/gh/ChenKS12138/ChenKS12138.github.io/static/6b1a2cd90b4f316614f2a1f0b93598cd/efc66/goroutine-bench1.png 885w,\nhttps://cdn.jsdelivr.net/gh/ChenKS12138/ChenKS12138.github.io/static/6b1a2cd90b4f316614f2a1f0b93598cd/c83ae/goroutine-bench1.png 1180w,\nhttps://cdn.jsdelivr.net/gh/ChenKS12138/ChenKS12138.github.io/static/6b1a2cd90b4f316614f2a1f0b93598cd/6f969/goroutine-bench1.png 2518w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<hr>\n<p>后面我使用了一台 8 核 16GB 内存的云服务器进行测试，效果就比较明显了。sum2 函数的耗时明显降低。</p>\n<deckgo-highlight-code   >\n          <code slot=\"code\">processor\t: 6\nvendor_id\t: GenuineIntel\ncpu family\t: 6\nmodel\t\t: 85\nmodel name\t: Intel(R) Xeon(R) Platinum 8255C CPU @ 2.50GHz\nstepping\t: 5\nmicrocode\t: 0x1\ncpu MHz\t\t: 2494.140\ncache size\t: 36608 KB\nphysical id\t: 0\nsiblings\t: 8\ncore id\t\t: 6\ncpu cores\t: 8\napicid\t\t: 6\ninitial apicid\t: 6\nfpu\t\t: yes\nfpu_exception\t: yes\ncpuid level\t: 13\nwp\t\t: yes</code>\n        </deckgo-highlight-code>\n<deckgo-highlight-code   >\n          <code slot=\"code\">数据规模 sum1函数耗时(ns) sum2函数耗时(ns)\n1000\t975\t184791\n2000\t1744\t136564\n4000\t2452\t77209\n8000\t4462\t148065\n16000\t13041\t151411\n32000\t17729\t99903\n64000\t34824\t88240\n128000\t72507\t88009\n256000\t153425\t118217\n512000\t307149\t128954\n1024000\t716739\t218762\n2048000\t1498043\t340398\n4096000\t3121459\t741179\n8192000\t6512778\t1440240\n16384000\t12999638\t2841228\n32768000\t25421817\t5573615\n65536000\t52787702\t11216755\n131072000\t102977136\t22564239\n262144000\t212568740\t48269912\n524288000\t408104714\t90059294</code>\n        </deckgo-highlight-code>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"https://cdn.jsdelivr.net/gh/ChenKS12138/ChenKS12138.github.io/static/3a85a25e684b67a0d452a9d58e86f22f/27f8b/goroutine-bench2.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 39.86486486486486%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsSAAALEgHS3X78AAAA/ElEQVQoz21SC67EIAj0/nfd1FeroqA8Rmu3bdZkAiIMP12tVYlIW2s/0XvXlNIA9MfbKeVmc6UUjTFewXeipePg3m92kaaVm+bCynKS25tDZu/9FSwiA0tvTYYzMxuBKFXRRHUQ4Q7719cqDCHocRwPwlnh1NmCEAxQRTUz4apWXiNyOedB2HUeGNFCQTtWDZnkNgNH28OnT4Cc65OQqKjfNi2UNWW6gNlKLdpKUqHjlC+UPKX5YaZI6JCRzXj4TWuOmnavnIL2agnCn7I5d5tjCLvpVo2wRutITKLqaDvAMjBLLNeB9X5WW6N9bNQu2b7Vvn0GwRrL8n3r/zWgdjwWpOZWAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"bench2\"\n        title=\"bench2\"\n        src=\"https://cdn.jsdelivr.net/gh/ChenKS12138/ChenKS12138.github.io/static/3a85a25e684b67a0d452a9d58e86f22f/fcda8/goroutine-bench2.png\"\n        srcset=\"https://cdn.jsdelivr.net/gh/ChenKS12138/ChenKS12138.github.io/static/3a85a25e684b67a0d452a9d58e86f22f/12f09/goroutine-bench2.png 148w,\nhttps://cdn.jsdelivr.net/gh/ChenKS12138/ChenKS12138.github.io/static/3a85a25e684b67a0d452a9d58e86f22f/e4a3f/goroutine-bench2.png 295w,\nhttps://cdn.jsdelivr.net/gh/ChenKS12138/ChenKS12138.github.io/static/3a85a25e684b67a0d452a9d58e86f22f/fcda8/goroutine-bench2.png 590w,\nhttps://cdn.jsdelivr.net/gh/ChenKS12138/ChenKS12138.github.io/static/3a85a25e684b67a0d452a9d58e86f22f/efc66/goroutine-bench2.png 885w,\nhttps://cdn.jsdelivr.net/gh/ChenKS12138/ChenKS12138.github.io/static/3a85a25e684b67a0d452a9d58e86f22f/c83ae/goroutine-bench2.png 1180w,\nhttps://cdn.jsdelivr.net/gh/ChenKS12138/ChenKS12138.github.io/static/3a85a25e684b67a0d452a9d58e86f22f/27f8b/goroutine-bench2.png 1730w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<h2>分析</h2>\n<p>在求和数组规模数据规模比较大，运行的机器核心数比较多的时候，使用<code>go协程</code>是可以提升数组求和的效率的。<code>go协程</code>和系统的进程并不是一一对应的，创建一个<code>go协程</code>本身的开销也比创建一个线程小。对大数组求和只是一种场景，也有很多其他类似的场景可以利用<code>go协程</code>进行优化。</p>","id":"673cc44a-d8a8-5a00-8658-30c14b7d5249","headings":[{"value":"前言","depth":2},{"value":"对比","depth":2},{"value":"进行测试","depth":2},{"value":"分析","depth":2}],"date":"Monday, July 27, 2020 1:11 PM","tags":["go","随笔"],"title":"使用go协程优化求和算法"}},"staticQueryHashes":["63159454"]}