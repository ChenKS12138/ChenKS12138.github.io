{"componentChunkName":"component---src-pages-detail-tsx","path":"/detail/499f687f-1fb8-570e-8333-e69e768bd27a","result":{"pageContext":{"html":"<h2>什么是函数节流和函数防抖</h2>\n<p>这两者都是 JavaScript 中的一些优化方法。顾名思义，节流与防抖都是通过一定的方法，较少函数的调用频率，来达到优化的目的。</p>\n<h3>函数防抖 (Debounce)</h3>\n<p>主要是实现，当一定的事件间隔内连续多次触发指定的事件后，事件处理函数不会立即执行。仅在最后一次触发的若干毫秒后执行事件处理函数。这避免了事件处理函数的多次执行。</p>\n<h3>函数节流 (Throttle)</h3>\n<p>主要是实现，当指定事件被多次触发后，保证事件处理函数的执行的时间间隔是一样的，都是间隔若个毫秒。就像它的名字一样，是一个水流量很小的水龙头，但是它的流量是稳定的，即时间处理函数的被调用情况从时间上来看是均匀的。</p>\n<h3>应用场景</h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"https://cdn.jsdelivr.net/gh/ChenKS12138/ChenKS12138.github.io/static/9af98e1b4f6da32def8bf2ea9dd85cd1/42a96/debounce1.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 53.37837837837838%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAALABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAIEA//EABUBAQEAAAAAAAAAAAAAAAAAAAAB/9oADAMBAAIQAxAAAAG2t2RTUX//xAAbEAACAQUAAAAAAAAAAAAAAAABAgADBBASMv/aAAgBAQABBQIWqELTUDQYXmf/xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAaEAACAgMAAAAAAAAAAAAAAAAAARARMTKR/9oACAEBAAY/AtSkkYXIUf/EABkQAQEAAwEAAAAAAAAAAAAAAAERABBhkf/aAAgBAQABPyEIz7guAc1iyTHWdf/aAAwDAQACAAMAAAAQxB//xAAXEQEBAQEAAAAAAAAAAAAAAAABABEx/9oACAEDAQE/EADlt//EABcRAQADAAAAAAAAAAAAAAAAAAEQETH/2gAIAQIBAT8QtxY//8QAGxABAQEAAgMAAAAAAAAAAAAAAREAECExofH/2gAIAQEAAT8QQAM7K841s4CX3vgsoUS5mFUq8f/Z'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"新生杯\"\n        title=\"新生杯\"\n        src=\"https://cdn.jsdelivr.net/gh/ChenKS12138/ChenKS12138.github.io/static/9af98e1b4f6da32def8bf2ea9dd85cd1/1c72d/debounce1.jpg\"\n        srcset=\"https://cdn.jsdelivr.net/gh/ChenKS12138/ChenKS12138.github.io/static/9af98e1b4f6da32def8bf2ea9dd85cd1/a80bd/debounce1.jpg 148w,\nhttps://cdn.jsdelivr.net/gh/ChenKS12138/ChenKS12138.github.io/static/9af98e1b4f6da32def8bf2ea9dd85cd1/1c91a/debounce1.jpg 295w,\nhttps://cdn.jsdelivr.net/gh/ChenKS12138/ChenKS12138.github.io/static/9af98e1b4f6da32def8bf2ea9dd85cd1/1c72d/debounce1.jpg 590w,\nhttps://cdn.jsdelivr.net/gh/ChenKS12138/ChenKS12138.github.io/static/9af98e1b4f6da32def8bf2ea9dd85cd1/a8a14/debounce1.jpg 885w,\nhttps://cdn.jsdelivr.net/gh/ChenKS12138/ChenKS12138.github.io/static/9af98e1b4f6da32def8bf2ea9dd85cd1/fbd2c/debounce1.jpg 1180w,\nhttps://cdn.jsdelivr.net/gh/ChenKS12138/ChenKS12138.github.io/static/9af98e1b4f6da32def8bf2ea9dd85cd1/42a96/debounce1.jpg 1917w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>诶，这是在 2019 校科协新生杯的前端项目 <a href=\"https://github.com/ChenKS12138/sast_fresh_cup_frontend\">仓库地址</a> 里使用到的。先来说说这个项目吧，这是个前后端分离的项目，接口是我设计的，我们所要讨论的问题是出现在了答题页。答题页需要将题目从服务器端获取，并将选手填写的答案传送到服务器端。题目获取方面，其实更准确地说是，是一些比赛的基本信息方面，包括题目，公告，截至时间等，我就加了一个接口对这些信息求哈希，客户端轮询这个接口。 <del>用 websocket 可能会更好</del> ，一旦有变化，再请求其他相关的接口。因此题目是一次性获取的，并且可能会比赛中途更新。而在提交答案方面，我没有采用一次性提交的方式。主要是怕哪个大佬学弟自己把 localStorage 清除了。但是这就有了一个问题，无论是使用<code>setInterval</code> 定时将答案发送到给服务器，还是只给文字输入框加一个监听输入的处理函数，效率都不高。因此使用在这种情况下使用节流和防抖就很有用了。</p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">// debounce.js\nexport default function DebounceConstructor(fn, interval = 0) {\n  let timer;\n  let wraper;\n  function Debounce(...args) {\n    if (timer) clearTimeout(timer);\n    wraper = () =&gt; {\n      fn(...args);\n      timer = undefined;\n    };\n    timer = setTimeout(wraper, interval);\n  }\n  function Clear() {\n    if (timer !== undefined) {\n      clearTimeout(timer);\n      wraper();\n    }\n  }\n  return {\n    Debounce,\n    Clear,\n  };\n}</code>\n        </deckgo-highlight-code>\n<p>这是个闭包，从设计模式上来讲叫单例模式<code>singleton</code> 。</p>\n<p>因为我还需要在题目切换时，强制处理函数执行，所以多了一个<code>clear</code> 。</p>\n<p>调用处的代码</p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">// answer.vue\nimport DebounceConstructor from &quot;debounce.js&quot;;\nconst { Debounce: handleTyping, Clear: handleExecute } = DebounceConstructor(\n  val =&gt; {\n    submit(val);\n    console.log(val);\n  },\n  800\n);</code>\n        </deckgo-highlight-code>\n<p>这样就如最上面那张图片看到的那样，遇到一系列的输入时，每次输入框的值发生改变时，都会调用<code>handleTyping</code>，只有在停止输入若干毫秒后才会执行事件处理函数。</p>\n<h3>另一种处理方式</h3>\n<p>上面的方案是采用了防抖的方法。其实也可以采用节流的方式。这个可以仔细研究一下。</p>\n<h3>类似的场景</h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"https://cdn.jsdelivr.net/gh/ChenKS12138/ChenKS12138.github.io/static/2048a3c1396c9dac6c97f26115255c92/2f5f2/debounce2.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 72.97297297297297%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAPABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAEF/8QAFAEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEAMQAAAB3aoB/8QAFRABAQAAAAAAAAAAAAAAAAAAEEH/2gAIAQEAAQUCaf/EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABYQAAMAAAAAAAAAAAAAAAAAAAAgMf/aAAgBAQAGPwIq/wD/xAAZEAEAAwEBAAAAAAAAAAAAAAABEBEhADH/2gAIAQEAAT8hdwUeBFu0V6n/2gAMAwEAAgADAAAAEIPP/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPxA//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPxA//8QAGxABAAEFAQAAAAAAAAAAAAAAAREAECExQZH/2gAIAQEAAT8QU0g6UwIHRBixFHK8qXp5b//Z'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"搜索引擎\"\n        title=\"搜索引擎\"\n        src=\"https://cdn.jsdelivr.net/gh/ChenKS12138/ChenKS12138.github.io/static/2048a3c1396c9dac6c97f26115255c92/1c72d/debounce2.jpg\"\n        srcset=\"https://cdn.jsdelivr.net/gh/ChenKS12138/ChenKS12138.github.io/static/2048a3c1396c9dac6c97f26115255c92/a80bd/debounce2.jpg 148w,\nhttps://cdn.jsdelivr.net/gh/ChenKS12138/ChenKS12138.github.io/static/2048a3c1396c9dac6c97f26115255c92/1c91a/debounce2.jpg 295w,\nhttps://cdn.jsdelivr.net/gh/ChenKS12138/ChenKS12138.github.io/static/2048a3c1396c9dac6c97f26115255c92/1c72d/debounce2.jpg 590w,\nhttps://cdn.jsdelivr.net/gh/ChenKS12138/ChenKS12138.github.io/static/2048a3c1396c9dac6c97f26115255c92/2f5f2/debounce2.jpg 797w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>需要使用到节流和防抖的类似的场景还有很多。像我们在搜索引擎输入关键字，底下会有提示框，这也是个应用场景。</p>","id":"499f687f-1fb8-570e-8333-e69e768bd27a","headings":[{"value":"什么是函数节流和函数防抖","depth":2},{"value":"函数防抖 (Debounce)","depth":3},{"value":"函数节流 (Throttle)","depth":3},{"value":"应用场景","depth":3},{"value":"另一种处理方式","depth":3},{"value":"类似的场景","depth":3}],"date":"Saturday, August 10, 2019 10:42 PM","tags":["JavaScript"],"title":"JS中的函数节流与函数防抖"}},"staticQueryHashes":["63159454"]}